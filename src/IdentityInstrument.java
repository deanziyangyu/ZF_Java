/*
 * This Java source file was generated by the Gradle 'init' task.
 */
//package dev.navids.soottutorial.hellosoot;

//import dev.navids.soottutorial.visual.Visualizer;
import soot.*;
import soot.jimple.*;
import soot.options.Options;
import soot.util.*;
import soot.util.Chain.*;
import soot.jimple.NopStmt;
import soot.jimple.toolkits.callgraph.*;
import soot.jimple.internal.JIfStmt;
import soot.jimple.internal.*;
import soot.javaToJimple.LocalGenerator;
import soot.AbstractASMBackend;
import soot.baf.BafASMBackend;

import java.util.concurrent.ThreadLocalRandom;
import java.io.*;
import java.util.*;

public class IdentityInstrument {

    public static String sourceDir = System.getProperty("user.dir");
    public static int javaVersion;

    public static void configureSoot(String clsName, String methodName) {
        G.reset();
        Options.v().set_prepend_classpath(true);
        Options.v().set_allow_phantom_refs(true);
        Options.v().set_soot_classpath(sourceDir);
        javaVersion = Options.v().java_version();

        SootClass sc = Scene.v().loadClassAndSupport(clsName);
        sc.setApplicationClass();
        Scene.v().loadNecessaryClasses();
    }

    public static void generateOutput(SootClass sc) throws FileNotFoundException, IOException {
      String fileName = SourceLocator.v().getFileNameFor(sc, Options.output_format_class);
      OutputStream streamOut = new FileOutputStream(fileName);
      BafASMBackend backend = new BafASMBackend(sc, javaVersion);
      backend.generateClassFile(streamOut);
      streamOut.close();
    }

    public static void main(String[] args) {
        String clsName = args[0];
        String methodName = args[1];
        configureSoot(clsName, methodName);
        
        SootClass sc = Scene.v().getSootClass(clsName);
        SootMethod sm = sc.getMethodByName(methodName);
        JimpleBody body = (JimpleBody) sm.retrieveActiveBody();

        // Print some information
        System.out.println("Method Signature: " + sm.getSignature());
        System.out.println("Method Parameters: " + sm.getParameterTypes());
        System.out.println("Method Return TYpe: " + sm.getReturnType());

        System.out.println("--------------");
        System.out.println("Argument(s):");
        for (Local l : body.getParameterLocals()) {
            System.out.println(l.getName() + " : " + l.getType());
        }
        System.out.println("--------------");
        System.out.println("This:");
        try {
          System.out.println(body.getThisLocal());
        } catch (Exception e) {
          if (!methodName.equals("main")) {
            System.out.println("body.getThisLocal E: " + e);
          } else {
            System.out.println("main");
          }
        }
        System.out.println("--------------");
        System.out.println("Units:");

        int c = 1;

        Chain units = body.getUnits();
        Iterator<Stmt> stmtIt = units.snapshotIterator();
        while (stmtIt.hasNext()) {
          Stmt stmt = (Stmt) stmtIt.next();
          System.out.println("(" + c + ") " + stmt);
          c++;

          if (!stmt.containsInvokeExpr()) {
            continue;
          }

          InvokeExpr expr = (InvokeExpr) stmt.getInvokeExpr();

          System.out.println("\t" + expr);
          SootMethod method = stmt.getInvokeExpr().getMethod();
          System.out.println("\t" + method);
          System.out.println("\t    Sig: " + method.getSignature());
          System.out.println("\t    Sub: " + method.getSubSignature());
          System.out.println("\t    Par: " + method.getParameterTypes());
          System.out.println("\t    Ret: " + method.getReturnType());
        }
        System.out.println("--------------");

        // Print statements that have branch conditions
        System.out.println("Branch Statements:");
        for (Unit u : body.getUnits()) {
            if (u instanceof JIfStmt)
                System.out.println(u.toString());
        }

      try {
        generateOutput(sc);
      } catch (Exception e) {
        System.out.println("Transformed output cannot be generated: " + e);
      }

    }

}
