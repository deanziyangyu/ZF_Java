/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package dev.navids.soottutorial.hellosoot;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import dev.navids.soottutorial.visual.Visualizer;
import soot.*;
import soot.jimple.JimpleBody;
import soot.jimple.internal.*;
import soot.options.Options;
import soot.toolkits.graph.ClassicCompleteUnitGraph;
import soot.toolkits.graph.UnitGraph;


import java.io.File;

public class HelloSoot {

    public static String sourceDirectory = System.getProperty("user.dir") + File.separator + "demo" + File.separator + "CFG";
    public static String clsName = "UtilBSearch";
    public static String methodName = "binarySearch0";
    public static int LOOP_LIMIT = 3;

    public static ArrayList<Unit> branchList = new ArrayList<>();
    public static ArrayList<Unit> gotoList = new ArrayList<>();
    public static ArrayList<Unit> nbranchList = new ArrayList<>();
    public static ArrayList<List<Unit>> unit_paths;
    public static List<Unit> head;

    public static void setupSoot() {
        G.reset();
        Options.v().set_prepend_classpath(true);
        Options.v().set_allow_phantom_refs(true);
        Options.v().set_soot_classpath(sourceDirectory);
        SootClass sc = Scene.v().loadClassAndSupport(clsName);
        sc.setApplicationClass();
        Scene.v().loadNecessaryClasses();

    }

    public static void main(String[] args) {
        setupSoot();

        // Retrieve printFizzBuzz's body
        SootClass mainClass = Scene.v().getSootClass(clsName);
        SootMethod sm = mainClass.getMethodByName(methodName);
        JimpleBody body = (JimpleBody) sm.retrieveActiveBody();

        // Print some information about printFizzBuzz
        System.out.println("Method Signature: " + sm.getSignature());
        System.out.println("--------------");
        System.out.println("Argument(s):");
        for (Local l : body.getParameterLocals()) {
            System.out.println(l.getName() + " : " + l.getType());
        }
        System.out.println("--------------");
        // System.out.println("This: " + body.getThisLocal());
        System.out.println("--------------");
        System.out.println("Units:");

        ArrayList<Unit> nodeList = new ArrayList<>();
        int c = 1;
        for (Unit u : body.getUnits()) {
            System.out.println("(" + c + ") " + u.toString());
            c++;
            nodeList.add(u);
        }
        System.out.println("--------------");

        UnitGraph ug = new ClassicCompleteUnitGraph(sm.getActiveBody());

        // Print statements that have branch conditions
        System.out.println("\nBranch Statements:");
        for (Unit u : body.getUnits()) {
            if (u instanceof JIfStmt){
                System.out.println(u.toString());
                branchList.add(u);
            }else if (u instanceof JGotoStmt){
                gotoList.add(u);
            }
            else
                nbranchList.add(u);
        }
        System.out.println("\nGoto Jump Statements:");
        for (Unit u : gotoList){
            System.out.println(u.toString());
        }
        System.out.println("\nNonBranching Statements:");
        for (Unit u : nbranchList){
            System.out.println(u.toString());
        }
        
        // ug.getPredsOf(u)
        for (Unit u: nbranchList){
            System.out.println(u.toString());
        }
        head = ug.getHeads();
    
        System.out.println(head.toString());
    
        explore_call_paths(ug);

                // Print statements that have branch conditions
        System.out.println("\nBranch Statements:");
        for (Unit u : body.getUnits()) {
            if (u instanceof JIfStmt){
                System.out.println(u.toString());
                branchList.add(u);
            }else if (u instanceof JGotoStmt){
                gotoList.add(u);
            }
            else
                nbranchList.add(u);
        }
        System.out.println("\nGoto Jump Statements:");
        for (Unit u : gotoList){
            System.out.println(u.toString());
        }
        System.out.println("\nNonBranching Statements:");
        for (Unit u : nbranchList){
            System.out.println(u.toString());
        }

        // Draw the control-flow graph of the method if 'draw' is provided in arguments
        boolean drawGraph = false;
        if (args.length > 0 && args[0].equals("draw"))
            drawGraph = true;
        if (drawGraph) {
            // UnitGraph ug = new ClassicCompleteUnitGraph(sm.getActiveBody());
            Visualizer.v().addUnitGraph(ug);
            Visualizer.v().draw();
        }
    }

    public static void display_unit_path(){
        List<Unit> path;
        for(int i = 0; i < unit_paths.size(); i++){
            path = unit_paths.get(i);
            System.out.print(" --- Unit Path " + i + " --- \n" );
            for(int j = 0; j < path.size(); j++){
                if (j%37 == 0  && !((path.size()-j)<30)){
                    System.out.print(" --- Unit Path " + (j/5) + " --- \n" );
                }
                // if (String.format("Unit -- '%s'", path.get(j)).contains("if")){
                //     System.out.print(" --- Unit Sub Path " + (j/5) + " --- \n" );
                // }
                System.out.println(String.format("Unit -- '%s'", path.get(j)));
            }
        }
    }
        
    public static int max_repeat_instance(){
        //temporarily set it to be a fixed value
        return LOOP_LIMIT;
    }

    public static void exec_next_unit(UnitGraph unitgraph, HashMap<Unit, Integer> unit_table, ArrayList<Unit> unit_sequence, Unit current_unit){
        // Unit un;
        Unit next_unit;
        
        List<Unit> succ_list = unitgraph.getSuccsOf(current_unit);
        // Iterator<Unit> un_it = unitgraph.iterator(); 
        if(succ_list.isEmpty()){
            ArrayList<Unit> complete_sequence = new ArrayList<>();
            complete_sequence.addAll(unit_sequence);
            unit_paths.add(complete_sequence);
            return;
        }
        
        ArrayList<Unit> new_units = new ArrayList<>();
        ArrayList<Unit> exec_ed_units = new ArrayList<>();
        for(Unit u: succ_list){
            next_unit = u;
            if(!unit_table.containsKey(next_unit)){
                new_units.add(u);
            }
            else{
                exec_ed_units.add(u);
            }
        }

        for(Unit unit_to_exec : exec_ed_units){
            int occurrence_location = unit_table.get(unit_to_exec);
            ArrayList<Unit> repeat_sequence = new ArrayList<>();
            for(int i = occurrence_location; i < unit_sequence.size(); i++){
                repeat_sequence.add(unit_sequence.get(i));
            }
            int repeat_instance = max_repeat_instance();
            ArrayList<Unit> original_sequence = new ArrayList<>();
            original_sequence.addAll(unit_sequence);

            for(int i = 0; i < repeat_instance; i++){
                unit_sequence.addAll(repeat_sequence);
                for(Unit u_to_newu : new_units){
                    exec_next_unit(unitgraph, unit_table, unit_sequence, u_to_newu);
                }
            }
            //reset to the list before the looping around
            unit_sequence = new ArrayList<>();
            unit_sequence.addAll(original_sequence); 


        }

        for(Unit u_to_newu : new_units){
            next_unit = u_to_newu;
            unit_table.put(next_unit, Integer.valueOf(unit_sequence.size()));
            unit_sequence.add(u_to_newu);
            exec_next_unit(unitgraph, unit_table, unit_sequence, next_unit);
            unit_table.remove(next_unit);
            unit_sequence.remove(u_to_newu);
        }
    }

    public static void explore_call_paths(UnitGraph unitgraph){
        unit_paths = new ArrayList<>();
        HashMap<Unit, Integer> unit_table = new HashMap<>();
        ArrayList<Unit> unit_edges = new ArrayList<>();
        Unit start_unit;
        for(Iterator<Unit> un_it = unitgraph.iterator(); un_it.hasNext();){
            start_unit = un_it.next();
            if(start_unit == head.get(0)){
                unit_table.put(start_unit, 0);
                exec_next_unit(unitgraph, unit_table, unit_edges, start_unit);
                break;
            }
        }
        display_unit_path();
    }

}
